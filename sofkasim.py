#!/usr/bin/env python3
import argparse
from devices import get_device

"""
Sofka simulator for MUSYS.

Takes the output lists generated by the simulated
MUSYS compiler, musysim, and simulates the
effects of sending this data to various
hardware audio devices by generating
Nyquist code.

"""
DEBUG = False
PRELUDE = "(set-control-srate *sound-srate*)"


def dprint(*s):
    if DEBUG:
        print(*s)


class Sofka:
    def __init__(self, lists):
        self.lists = [b.split(' ') for b in lists.split('\n')]
        self.clock = 100  # Interrupts per second
                          # default implied by example at http://users.encs.concordia.ca/~grogono/Bio/ems.html
        self.oscillators = [None] * 3
        self.envelopes = [None] * 3
        self.current_time = 0

    def perform(self):
        # TODO this needs to be refactored once a sensible system
        # for combining all the audio sources and effects for 
        # all six lists is settled on.
        for b in self.lists:
            if not b[0]:
                continue
            for c in b:
                n = int(c[:2], 8)
                v = int(c[2:], 8)
                device = get_device(int(c[:2], 8))
                dprint(device, c)
                if n == 62:  # Interrupt timer
                    self.clock = v
                if 0 < n < 4:  # Osc
                    dprint('OSC', n)
                    if self.oscillators[n - 1]:
                        self.oscillators[n - 1].change(v)
                    else:
                        self.oscillators[n - 1] = Oscillator(v)
                    self.active = n - 1
                if 23 < n < 27:  # Envelopes
                    n = n - 24
                    dprint('Envelope', n + 1)
                    t = self.current_time
                    d = self.secs(v)
                    if self.envelopes[n]:
                        self.envelopes[n].addtime(t, d)
                    else:
                        self.envelopes[n] = Envelope(t, d)
                    self.current_time += d
                    self.oscillators[self.active].duration += d
                if n == 60:  # Wait timer
                    d = self.secs(v)
                    dprint('WAIT:', d)
                    self.current_time += d
                    self.oscillators[self.active].duration += d
        # write the generated audio
        sources = [o for o in self.oscillators if o]
        sources += [e for e in self.envelopes if e]
        dprint('SOURCES', sources)
        output = ' '.join(['(seq %s)' % ' '.join(s.out()) for s in sources])
        return '(mult %s)' % output

    def secs(self, n):
        """ Number of seconds of time with current clock."""
        return n * 1 / self.clock


class Envelope:
    def __init__(self, current_time, duration):
        self.durations = []  # list of (time, duration) for alternating attack / decay
        self.addtime(current_time, duration)
        self.history = []

    def addtime(self, t, d):
        """
        t float: current time (seconds)
        d float: duration (seconds)
        """
        self.durations.append((t, d))

    def out(self):
        stage = 1  # 1: attack, 0: decay
        breakpoints = []
        for duration in self.durations:
            t_prev = breakpoints[-2] if breakpoints else 0
            level = 1 - stage
            if duration[0] < t_prev:
                breakpoints[-2] = duration[0]
                breakpoints[-1] = min(level, 0.5)
            else:
                breakpoints += [duration[0], level]
            breakpoints += [sum(duration), stage]
            stage = 1 - stage
        breakpoints = ' '.join([str(round(v, 3)) for v in breakpoints])
        return [f"(pwl-list '({breakpoints}))"]


class Oscillator:
    def __init__(self, pitch=32):
        # Hypothesised: {Nyquist (MIDI) tone} = {MUSYS tone} + 28
        # Middle C = Nyquist 60, MUSYS 32
        self.pitch = pitch + 28
        self.duration = 0
        self.history = []

    def change(self, pitch):
        self.history.append(self.out(False))
        self.pitch = pitch + 28
        self.duration = 0

    def out(self, history=True):
        if not history:
            return "(osc %s %s)" % (self.pitch, round(self.duration, 3))
        self.change(0)
        return self.history


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description="MUSYS (1973) Sofka simulator.")
    #parser.add_argument('file', help='compiled MUSYS data lists to perform')
    parser.add_argument('-d', '--debug', help='turn on debug output', action='store_true')
    args = parser.parse_args()

    DEBUG = args.debug
    listfile = 'musys.out'
    with open(listfile, 'r') as f:
        s = Sofka(f.read())

    print(f'{PRELUDE}(play {s.perform()})')

