#!/usr/bin/env python3
import argparse
from devices import get_device


"""
Sofka simulator for MUSYS.

Takes the output lists generated by the simulated
MUSYS compiler, musysim, and simulates the
effects of sending this data to various
hardware audio devices by generating
Nyquist code.

"""


DEBUG = False
MAX_INTERRUPT_FREQ = 16000
PRELUDE = f"(set-control-srate {MAX_INTERRUPT_FREQ})"


def dprint(*s):
    if DEBUG:
        print(*s)


def freq(pitch):
    """Converts a Nyquist pitch number to Hz."""
    if pitch == 0:
        return 0
    return 440 * 2 ** ((pitch - 69) / 12)


def attack_ms(n:int, min_=1, max_=1000):
    return n**2 * (max_ - min_)/(63**2) + min_


def decay_ms(n:int, min_=10, max_=10000):
    return n**2 * (max_ - min_)/(63**2) + min_


class Sofka:
    def __init__(self, lists):
        self.lists = [b.split(' ') for b in lists.split('\n')]
        self.clock = 100  # Interrupts per second
                          # default implied by example at http://users.encs.concordia.ca/~grogono/Bio/ems.html
        self.oscillators = [Oscillator(0) for i in range(3)]
        self.envelopes = [None] * 3
        self.current_time = 0

    def perform(self):
        # TODO this needs to be refactored once a sensible system
        # for combining all the audio sources and effects for 
        # all six lists is settled on.
        for b in self.lists:
            if not b[0]:
                continue
            for c in b:
                n = int(c[:2], 8)
                v = int(c[2:], 8)
                device = get_device(int(c[:2], 8))
                dprint(f'\n{device} {c}')
                if n == 62:  # Interrupt timer
                    self.clock = v
                if 0 < n < 4:  # Osc
                    dprint('OSC', n)
                    if self.oscillators[n - 1]:
                        self.oscillators[n - 1].change(v)
                if 23 < n < 27:  # Envelopes
                    n = n - 24
                    dprint('Envelope', n + 1)
                    t = self.current_time
                    if self.envelopes[n]:
                        self.envelopes[n].addstage(t, v)
                    else:
                        self.envelopes[n] = Envelope(t, v)
                if n == 60:  # Wait timer
                    d = self.secs(v)
                    dprint('WAIT:', d)
                    self.current_time += d
                    [osc.addtime(d) for osc in self.oscillators if osc]

        # Write the generated audio
        # TODO:
        # mix oscillators, envelopes, and their amplifiers as patched
        # mix signals
        signals = []
        for i, osc in enumerate(self.oscillators):
            if not osc.history:
                continue
            if env := self.envelopes[i]:
                signals.append(f'(mult {osc.out()} {env.out()})')
            else:
                signals.append(osc.out())
        dprint('SIGNALS', signals)
        #output = ' '.join(['(seq %s)' % ' '.join(s.out()) for s in sources])
        output = ' '.join(signals)
        return f'(sim {output})'

    def secs(self, n) -> float:
        """ Number of seconds of time with current clock."""
        return n * 1 / self.clock


class Envelope:
    def __init__(self, current_time, duration:int):
        self.stages = []  # list of (time, duration in seconds) for alternating attack / decay
        self.addstage(current_time, duration)
        self.history = []

    def addstage(self, t:float, d:int):
        """
        t float: current time (seconds)
        d int: duration (11bit envelope value)
        """
        stage_ms = decay_ms if (len(self.stages) & 1) else attack_ms
        self.stages.append((t, stage_ms(d)/1000))

    def out(self) -> str:
        dprint('ENV:', self.stages)
        level = 0  # 0: attack, 1: decay
        breakpoints = []
        for stage in self.stages:
            t_prev = breakpoints[-2] if breakpoints else 0

            if stage[0] < t_prev:
                breakpoints[-2] = stage[0]
                breakpoints[-1] = min(level, 0.5)
            else:
                breakpoints += [stage[0], level]
            level = 1 - level
            breakpoints += [sum(stage), level]
        breakpoints = ' '.join([str(round(v, 3)) for v in breakpoints])
        return f"(pwl-list '({breakpoints}))"


class Oscillator:
    def __init__(self, pitch=32):
        # Hypothesised: {Nyquist (MIDI) tone} = {MUSYS tone} + 28
        # Middle C = Nyquist 60, MUSYS 32
        self.pitch = pitch + 28 if pitch else 0
        self.duration = 0
        self.phase = 0
        self.history = []  # list of nyquist commands to seq

    def addtime(self, d):
        self.duration += d

    def change(self, pitch):
        if self.pitch == 0 and self.duration:
            self.history.append(f"(s-rest {round(self.duration, 3)})")
            self.pitch = pitch + 28 if pitch else 0
            self.duration = 0
            return
        elif self.duration != 0:
            self.history.append(
                f"(osc {self.pitch} {round(self.duration, 3)} *table* {round(self.phase, 3)})"
            )
        self.pitch = pitch + 28 if pitch else 0
        self.phase = (self.phase + self.duration * freq(self.pitch)) % 360
        self.duration = 0

    def out(self) -> str:
        self.change(0)
        output = ' '.join(self.history)
        return f'(seq {output})'


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description="MUSYS (1973) Sofka simulator.")
    #parser.add_argument('file', help='compiled MUSYS data lists to perform')
    parser.add_argument('-d', '--debug', help='turn on debug output', action='store_true')
    args = parser.parse_args()

    DEBUG = args.debug
    listfile = 'musys.out'
    with open(listfile, 'r') as f:
        s = Sofka(f.read())

    print(f'{PRELUDE}(play {s.perform()})')

